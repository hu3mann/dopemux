import os
import json
import hashlib
import subprocess
from pathlib import Path
from datetime import datetime, timezone
from collections import defaultdict

REPO_ROOT = Path(__file__).resolve().parent

LANG_MAP = {
    '.py': 'Python',
    '.md': 'Markdown',
    '.yaml': 'YAML',
    '.yml': 'YAML',
    '.json': 'JSON',
    '.sh': 'Shell',
    '.txt': 'Text',
}

PY_COMPILED = 0

TYPE_MAP = {
    'py': 'code',
    'md': 'doc',
    'yaml': 'config',
    'yml': 'config',
    'json': 'config',
    'sh': 'script',
}


def detect_language(path: Path) -> str:
    ext = path.suffix.lower()
    if ext in LANG_MAP:
        return LANG_MAP[ext]
    try:
        out = subprocess.check_output(['file', '--mime-type', str(path)])
        mime = out.decode().strip().split(':')[-1].strip()
        if 'python' in mime:
            return 'Python'
        if 'shell' in mime:
            return 'Shell'
        if 'text' in mime:
            return 'Text'
        return mime
    except Exception:
        return 'Unknown'


def detect_type(path: Path) -> str:
    ext = path.suffix.lower().lstrip('.')
    if ext in TYPE_MAP:
        return TYPE_MAP[ext]
    parts = path.parts
    if 'build' in parts or 'dist' in parts:
        return 'build-artifact'
    if 'docs' in parts or 'doc' in parts:
        return 'doc'
    return 'other'


def sha1(path: Path) -> str:
    h = hashlib.sha1()
    with open(path, 'rb') as f:
        while True:
            chunk = f.read(8192)
            if not chunk:
                break
            h.update(chunk)
    return h.hexdigest()


def python_compile(path: Path) -> str:
    try:
        subprocess.check_output(
            ['python', '-m', 'py_compile', str(path)],
            stderr=subprocess.STDOUT,
            timeout=5,
        )
        return ''
    except subprocess.CalledProcessError as e:
        return e.output.decode()
    except subprocess.TimeoutExpired:
        return 'compile timeout'


def audit_file(path: Path, duplicate_of: Path = None) -> dict:
    record = {
        'path': str(path.relative_to(REPO_ROOT)),
        'type': detect_type(path),
        'language': detect_language(path),
        'size_bytes': path.stat().st_size,
        'last_modified': datetime.fromtimestamp(path.stat().st_mtime, timezone.utc).isoformat(),
        'status': 'good',
        'reason': 'ok',
    }
    if duplicate_of:
        record['status'] = 'junk'
        record['reason'] = f'duplicate of {duplicate_of}'
        return record

    if record['language'] == 'Python' and record['type'] == 'code' and record['size_bytes'] < 500000:
        global PY_COMPILED
        if PY_COMPILED < 10:
            err = python_compile(path)
            PY_COMPILED += 1
            if err:
                record['status'] = 'broken'
                record['reason'] = err.splitlines()[0][:120]
    return record


def main():
    git_output = subprocess.check_output(['git', 'ls-files', '-z'], cwd=REPO_ROOT)
    git_files = [Path(p) for p in git_output.decode().split('\0') if p]
    tracked = {REPO_ROOT / f for f in git_files}
    all_files = set(tracked)

    for root, _, files in os.walk(REPO_ROOT):
        for name in files:
            p = Path(root) / name
            if p in all_files:
                continue
            if '.git' in p.parts:
                continue
            all_files.add(p)

    hashes = defaultdict(list)
    for f in all_files:
        hashes[sha1(f)].append(f)

    audit = []
    for files in hashes.values():
        first = files[0]
        audit.append(audit_file(first))
        for dup in files[1:]:
            audit.append(audit_file(dup, first))

    with open('audit.json', 'w') as fh:
        json.dump(audit, fh, indent=2)

    summary = defaultdict(lambda: defaultdict(int))
    for rec in audit:
        summary[rec['language']][rec['status']] += 1

    with open('AUDIT.md', 'w') as fh:
        fh.write('# Repo Audit\n\n')
        fh.write('| Language | good | bad | broken | junk |\n')
        fh.write('|----------|------|-----|--------|------|\n')
        for lang, stats in summary.items():
            fh.write(f"| {lang} | {stats.get('good',0)} | {stats.get('bad',0)} | {stats.get('broken',0)} | {stats.get('junk',0)} |\n")
        fh.write('\nGenerated by repo_audit.py\n')

if __name__ == '__main__':
    main()
